  
**Controller abstraction and multiple entry**

The controller abstraction leaks another system level concern, the concept of the active controller, into the realm of the developer.  

Instead of providing a useful abstraction, Android's hooks conflate user events and system level events.  This design needlessly complicates Android's controllers, because now they are responsible for responding to user input, like navigating to another view AND system level events, like if the app is backgrounded, through a single hook.  Since the "paused" state can be reached through multiple channels, and it does not describe an action that a developer should need to take, the developer must differentiate between the two kinds of events and act accordingly.  Furthermore, in older versions of Android, the view can actually be killed at this point, with no other hook being called, so this can be the developer's one chance to persist the state of the view and controller.  I actually don't know off the top of my head what happens in the controller when a modal is displayed in iOS.  And that's the point, I shouldn't have to care.  

For instance, it exposes the multiple entry points and multiple outcomes of the `onPause` hook.  Sometimes the `onPause` hook is called on its own, such as, if a modal overlays the current view.  Sometimes, it is called in conjunction with `onStop`, such as when the user navigates to a new view.  From Android's documentation, "When the system calls onPause() for your activity, it technically means your activity is still partially visible, but most often is an indication that the user is leaving the activity and it will soon enter the Stopped state."  The insidious part about having these multiple entry points is that **sometimes** actions are necessary in onPause, but sometimes they are not necessary, and the developer is responsible for handling each case.  For instance, if the modal gets dismissed and the view comes back to the foreground, the state of the view should be largely preserved, maybe with some changes from the information from the modal. But, if the app is backgrounded with the modal still showing, and then the app is killed, in older versions of Android `onStop` is not guaranteed to be called, so `onPause` could have been the only chance a developer had to persist the state of the view and controller.  Thus, sometimes, the state of the view should be saved in onPause, but sometimes it should not.  

 For instance if a view goes off screen, should the view be cached?  Should its state be persisted?  What happens if a bunch of views are saved in memory, but system resources run low: does the system destroy views in the background to reclaim memory?  The app has to handle all of these cases and more.  In general, Apple has managed to abstract away a lot of this complexity, while Android exposes it to the developer, creating major headaches.   

For instance, the onPause hook can be called for a number of reasons: the app has been backgrounded, the user has closed the app, another view has appeared, etc.  Sometimes, this method can be followed by a call to onDestroy, but that's not necessarily the case.  Sometimes, the app might have to save itself, signaled by another hook, onSaveInstanceState.  But onSaveInstanceState is not guaranteed to be called, for instance if the user "intentionally exits the view," whatever that means.  The developer must be aware of these different cases when deciding what to put in what hook.  

 Android envisioned view controllers that are active on screen, paused while something else is in the foreground, stopped, such as if the app is backgrounded, or destroyed such that it has to be recreated from scratch.  To reflect these states, they provided hooks like onPause and onStop.  These hooks define a set of states that a view controller can exist in with multiple entry points, which is fundamentally different than the linear approach favored by Apple.  

**Memory**

Furthermore,  `onPause` and `onStop` hooks conspire to leak a low level and horrendously complex system level concern into the realm of the developer.  A developer also has to be aware if the system decides to reclaim memory from his or her app, which is absolutely a system level concern, and should not be handled by the average developer.  Let's say you have a view on screen with a form.  The user has filled out some data, and then gets a phone call.  Normally, when the call is finished and the user reopens the app, the view will come back the same, with all of the data still filled in.  However, let's say the user has a bunch of stuff running in the background, and the phone runs out of memory.  It can kill the app in the background, which clears the data associated with the view.  So, the app will come back without the data (that is, if it doesn't crash, future blog post subject).  To solve this issue, the developer has to manually save the state of the view. On the other hand, in iOS, ARC handles release memory automatically.  The developer simply needs to save any relevant information, like user input, in `viewWillDisappear`.  The developer does not need to worry about why the view is getting hidden, and also does not need to worry about caching the state of the view.  It's one hook, with one entry point, that's simple, clean, and intuitive. 

If Android really wanted to abstract at the controller level, they should have given us relevant hooks.  We should have a hook if the app is backgrounded 

**Fragments**

As if Android lifecycle isn't confusing enough, Android has an additional set of lifecycle hooks for Fragments that are interleaved with the hooks of the parent activity, as outlined below.  

![Android Lifecycle](/images/lifecycle/fragment-lifecycle-android.png)

Confusing, no?  

**Crashes**

Here’s an example of an easy way to crash an activity with click listeners.  In the following app, there are two buttons that each update their state and then navigate to the next screen.  Seems simple right?  But, if I click them both in quick succession, the app will crash!  Here’s what’s happening.  If I click on both of them, both onClickListeners will be queued on the main thread.  When the first one executes, it updates it’s view state, and then starts the navigation process to the next activity, which destroys the current activity.  Then, the next onClickListener gets executed.  When that button tries to update it’s view, it finds that the activity, along with the view, have already been destroyed.  Thus, the button doesn’t exist anymore, and the program crashes with a NullPointerException.  The only way that I’ve found to prevent this crash is to wrap every possible asynchronous call in the following conditional.  [Insert conditional] It’s ugly, annoying, and easy to forget.  I believe that this crash reflects some really poor design choices, and reflects some shortcomings of Java.  There is no equivalent idiocy on iOS.  

In fact, there are many ways to create NullPointerExceptions with Android Activities, and in my mind, it’s inexcusable that the platform makes you worry about them.  Ever had an Android app crash on you when you bring it to the foreground?  Well, the following examples shows why this happens.  

[Insert app backgrounding example]

**Other**

The optimizations that Android made to reclaim memory and CPU from backgrounded views leak out into the realm of the developer, causing numerous crashes and introducing significant complexity. 

I’ll also note that there are a number of other hooks that can be used on each platform, but their use is discouraged.  One example is Android’s OnGlobalLayoutListener which can be used to manipulate the view after the view has been laid out.  However, since Android views should be responsive, manual measurement usually isn’t necessary and this method should be used sparingly.  Also, on iOS, there is often a strong temptation to use viewDidAppear.  If you manipulate the view after the view is on screen, you'll often see weird flashes and resizing views in your app.  Unless you know what you are doing, modify views in viewWillAppear.  It's fine to do background operations that don't affect the view in viewDidAppear.

As you can see, for the most part in iOS, the developer doesn't need to worry about what is happening to the view controller.  The developer is only responsible for performing the necessary actions to show the view on screen, and the system handles the complexity around saved states, foregrounding, backgrounding.  On the other hand, because Android developers must take action according to the state of the view controller, they assume responsibility for the complexity and the edge cases associated with the tasks of the view controller.  This responsibility leaks system level concerns into view controller code, and represents a massive increase in the complexity and responsibilities of the app code.  From personal experience, eight months into the development of my first Android app, I was still encountering issues, edge cases, and crashes pertaining to lifecycle.  I was still having to refer to lifecycle documentation, and it seemed like every week I was discovering a new hook.  On the other hand, I coded in iOS for months without appreciating what was being handled for me in the background.  It just worked. 